# ADR-001: Memory Architecture Selection

**Status:** Accepted  
**Date:** 2025-11-17  
**Decision Makers:** @aRustyDev  
**Tags:** architecture, memory, mcp, ai-agents

## Context

We need a memory solution for AI agents working across multiple personal projects. The system must support:

1. **Semantic search** - Find relevant information by meaning, not just keywords
2. **Graph relationships** - Model dependencies, architecture decisions, and connections
3. **Project isolation** - UUID-based namespacing to prevent cross-project pollution
4. **Single-user scale** - Personal projects, not enterprise/team collaboration
5. **Persistence** - Remember decisions, preferences, and context across sessions

### Requirements

- Support project-scoped memory with UUID namespacing
- Enable semantic search across project files and decisions
- Model complex relationships (dependencies, architecture, temporal decisions)
- Work with multiple repositories without cross-contamination
- Minimal infrastructure overhead for single-user setup

## Decision

**Selected: Graphiti + Kuzu**

Single memory system using Graphiti MCP Server with Kuzu backend for temporal knowledge graphs.

### Alternatives Considered

#### Option 1: Three-System Approach (Rejected)
- **mcp/memory** - General configs/preferences
- **OpenMemory** - Semantic search across projects  
- **Graphiti + Kuzu** - Graph-based analysis

**Rejected because:**
- Significant feature overlap (~80%) across all three systems
- Data synchronization complexity (3 sources of truth)
- Agent context switching overhead ("which system for this data?")
- 6+ infrastructure processes for single-user use
- Maintenance burden outweighs specialization benefits

#### Option 2: OpenMemory + Neo4j (Considered)
- **OpenMemory** - Best-in-class semantic search (Qdrant)
- **Neo4j** - Enterprise graph database

**Rejected because:**
- Requires managing 4 databases (Postgres + Qdrant + Neo4j + coordination)
- Over-engineered for single-user scale
- Sync complexity between semantic and graph stores
- Higher infrastructure cost vs benefit

#### Option 3: Just mcp/memory (Rejected)
- Simple JSON file-based knowledge graph

**Rejected because:**
- No semantic search capabilities
- Limited graph query capabilities
- JSON file doesn't scale beyond toy projects
- Missing temporal awareness

## Rationale

### Why Graphiti + Kuzu Wins

**1. Single Source of Truth**
- No synchronization needed
- No data drift between systems
- Clear agent decision-making (one place to store/search)

**2. Hybrid Search Excellence**
Graphiti provides three search modes in one:
- **Semantic** - Vector embeddings for meaning-based search
- **Keyword** - BM25 for exact term matching
- **Graph traversal** - Relationship-aware queries

This eliminates the need for separate semantic (OpenMemory) and graph (Neo4j) systems.

**3. Temporal Awareness**
- Bi-temporal model tracks when events occurred AND when they were recorded
- Point-in-time queries ("what was the architecture decision in March?")
- Critical for understanding project evolution

**4. Minimal Infrastructure**
- 2 processes: Graphiti server + Kuzu database
- Kuzu is lightweight (~100MB vs Neo4j's ~500MB)
- Single database to backup/maintain

**5. UUID Namespace Native Support**
```python
# Project-scoped entities
graphiti.add_entity(
    name="deployment-strategy",
    namespace="1E883314-E3B4-4453-BFCF-098BE37CAF79",
    attributes={"decision": "cloudflare-workers"}
)

# Cross-project search with filtering
graphiti.search(
    "authentication patterns",
    filter={"project_id": "1E883314-..."}
)
```

**6. Purpose-Built for AI Agents**
- Real-time updates for dynamic environments
- Designed for agent workflows (not retrofitted)
- MCP server integration out-of-box

### Capabilities Coverage

| Capability | mcp/memory | OpenMemory | Graphiti + Kuzu |
|------------|------------|------------|-----------------|
| Preferences/Configs | ✅ | ✅ | ✅ Entity attributes |
| Semantic Search | ❌ | ✅ | ✅ Hybrid search |
| Graph Relations | ⚠️ Basic | ⚠️ Limited | ✅ Full Cypher |
| Temporal Queries | ❌ | ⚠️ Timestamps | ✅ Bi-temporal |
| Cross-project Search | ✅ | ✅ | ✅ Namespace filter |
| Infrastructure | 1 JSON file | 3 services | 2 processes |
| Agent Complexity | Low | Medium | Medium |

## Implementation

### Setup
```bash
# Install Graphiti with Kuzu backend
pip install graphiti-core[kuzu]

# Configure MCP server
# Add to claude_desktop_config.json or Zed settings
```

### Memory Rules (.rules file)
```markdown
- Use the **Graphiti** MCP Server for all persistent memory:
  - Namespace: `{PROJECT_ID}::` from `git config --get project.id`
  - Store preferences/configs as entity attributes
  - Store decisions/architecture as entities with relationships
  - Embed document content for semantic search
  - Create temporal relationships (when decisions were made)
  - Search with hybrid mode: `search(query, project_filter)`
  - Session start: Query `{PROJECT_ID}::*` entities for context
  - Session end: Add new decisions/learnings as entities
  - NEVER access entities outside current project namespace
```

### Migration Path

If needs evolve:
```
Graphiti alone (current decision)
  ↓
Add mcp/memory for session-local scratch pad (if needed)
  ↓  
Add OpenMemory for specialized semantic search (if really needed)
```

Start simple, add complexity only when genuine pain is felt.

## Consequences

### Positive
- ✅ Single source of truth eliminates sync issues
- ✅ Lower maintenance burden (2 processes vs 6+)
- ✅ Agent clarity (one system to learn)
- ✅ Temporal awareness for decision tracking
- ✅ Hybrid search covers semantic + graph needs
- ✅ Easy to add specialized systems later if needed

### Negative
- ⚠️ Newer project (less mature than Neo4j/OpenMemory)
- ⚠️ Single point of failure (mitigated by backups)
- ⚠️ Learning Kuzu query language (similar to Cypher)

### Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Graphiti immaturity | Active development, can migrate to Neo4j backend |
| Performance at scale | Single-user scale unlikely to hit limits |
| Vendor lock-in | Kuzu data portable, standard graph formats |

## References

- [Graphiti GitHub](https://github.com/getzep/graphiti)
- [Graphiti MCP Server Documentation](https://playbooks.com/mcp/zep-graphiti)
- [Kuzu Database](https://kuzudb.com/)
- [Model Context Protocol (MCP)](https://modelcontextprotocol.io/)

## Notes

This decision follows the YAGNI principle (You Aren't Gonna Need It). For single-user personal projects, simplicity trumps specialization. The three-system approach was rejected as premature optimization.

Complexity is the enemy of getting things done. Start simple, iterate based on real pain points.
